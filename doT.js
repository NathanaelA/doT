// Generated by CoffeeScript 1.4.0

/*
  doT.js
  2011, Laura Doktorova, https://github.com/olado/doT
  
  doT.js is an open source component of http://bebedo.com
  Licensed under the MIT license.
*/


(function() {
  "use strict";

  var cache, doT, encodeHTMLSource, resolveDefs, sid, skip, startend, tags, unescape;

  startend = {
    append: {
      start: "'+(",
      end: ")+'",
      startencode: "'+doT.eh("
    },
    split: {
      start: "';out+=(",
      end: ");out+='",
      startencode: "';out+=doT.eh("
    }
  };

  doT = {
    version: '0.2.0',
    templateSettings: {
      use: /\{\{#([\s\S]+?)\}\}/g,
      define: /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
      varname: 'it',
      strip: true,
      "with": true,
      dynamicList: 'it._dynamic',
      startend: startend.append
    },
    startend: startend,
    tags: {}
  };

  cache = {};

  sid = 0;

  skip = /$^/;

  tags = doT.tags;

  tags.interpolate = {
    regex: /\{\{=([\s\S]+?)\}\}/g,
    func: function(m, code) {
      var cse;
      cse = doT.templateSettings.startend;
      return cse.start + unescape(code) + cse.end;
    }
  };

  tags.encode = {
    regex: /\{\{!([\s\S]+?)\}\}/g,
    func: function(m, code) {
      var cse;
      cse = doT.templateSettings.startend;
      return cse.startencode + unescape(code) + cse.end;
    }
  };

  tags.conditional = {
    regex: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
    func: function(m, elsecase, code) {
      if (elsecase) {
        if (code) {
          return "' ; } else if ( " + (unescape(code)) + " ) { out += '";
        } else {
          return "'; } else { out += '";
        }
      } else {
        if (code) {
          return "'; if ( " + (unescape(code)) + " ) { out += '";
        } else {
          return "'; } out += '";
        }
      }
    }
  };

  tags.iterate = {
    regex: /\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
    func: function(m, iterate, vname, iname) {
      var indv;
      if (!iterate) {
        return "'; } } out += '";
      }
      sid += 1;
      indv = iname || 'i' + sid;
      iterate = unescape(iterate);
      return "';var arr" + sid + " = " + iterate + ";if( arr" + sid + " ) {  var " + vname + ", " + indv + " = -1, l" + sid + " = arr" + sid + ".length-1;  while( " + indv + " < l" + sid + " ){    " + vname + " = arr" + sid + "[" + indv + " += 1];    out += '";
    }
  };

  tags.iterateFor = {
    regex: /\{\{:\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
    func: function(m, iterate, vname, iname) {
      var inpname;
      if (!iterate) {
        return "'; } } out += '";
      }
      sid += 1;
      inpname = 'iter' + sid;
      return "';var " + inpname + " = " + iterate + ";if ( " + inpname + " ) {  var " + vname + ", " + iname + ";  for (" + iname + " in " + inpname + " ) {    " + vname + " = " + inpname + "[ " + iname + " ];    out += '";
    }
  };

  tags.xx_includeDynamic = {
    regex: /\{\{@@([\S]+?)\([\s]*([\s\S]*?)[\s]*\)\}\}/g,
    func: function(m, tmpl, args) {
      var vname;
      sid += 1;
      vname = 'tmpl' + sid;
      return "';var " + vname + " = " + doT.templateSettings.dynamicList + "[ '" + (unescape(tmpl)) + "' ];if ('string' === typeof " + vname + ") " + vname + " = {name: " + vname + "};out += doT.render({name: " + vname + ".name, args: " + vname + ".args || arguments}) + '";
    }
  };

  tags.xy_render = {
    regex: /\{\{@([\S]+?)\([\s]*([\s\S]*?)[\s]*\)\}\}/g,
    func: function(m, tmpl, args) {
      return "' + doT.render( '" + tmpl + "' " + (args ? "," + (unescape(args)) : '') + " ) + '";
    }
  };

  tags.zz_evaluate = {
    regex: /\{\{([\s\S]+?)\}\}/g,
    func: function(m, code) {
      return "'; " + (unescape(code)) + "; out += '";
    }
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = doT;
  } else if (typeof define === 'function' && define.amd) {
    define(function() {
      return doT;
    });
  } else {
    this.doT = doT;
  }

  encodeHTMLSource = function() {
    var encodeHTMLRules, matchHTML;
    encodeHTMLRules = {
      "&": "&#38;",
      "<": "&#60;",
      ">": "&#62;",
      '"': '&#34;',
      "'": '&#39;',
      "/": '&#47;'
    };
    matchHTML = /&(?!#?\w+;)|<|>|"|'|\//g;
    return function(code) {
      if (code) {
        return code.toString().replace(matchHTML, function(m) {
          return encodeHTMLRules[m] || m;
        });
      } else {
        return code;
      }
    };
  };

  doT.encodeHTML = encodeHTMLSource();

  doT.eh = doT.encodeHTML;

  unescape = function(code) {
    return code.replace(/\\('|\\)/g, "$1").replace(/[\r\t\n]/g, ' ');
  };

  doT.unescape = unescape;

  resolveDefs = function(c, block, def) {
    return (typeof block === 'string' ? block : block.toString()).replace(c.define || skip, function(m, code, assign, value) {
      if (0 === code.indexOf('def.')) {
        code = code.substring;
      }
      if (!(code in def)) {
        if (':' === assign) {
          def[code] = value;
        } else {
          eval("def['" + code + "']=" + value);
        }
      }
      return '';
    }).replace(c.use || skip, function(m, code) {
      var v;
      v = eval(code);
      if (v) {
        return resolveDefs(c, v, def);
      } else {
        return v;
      }
    });
  };

  doT.template = function(tmpl, def) {
    var c, olddef, str, t_id, t_name, taglist;
    c = doT.templateSettings;
    str;

    if (c.use || c.define) {
      olddef = global.def;
      global.def = def || {};
      str = resolveDefs(c, tmpl, global.def);
      global.def = olddef;
    } else {
      str = tmpl;
    }
    if (c.strip) {
      str = str.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g, ' ').replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g, '');
    }
    str = str.replace(/'|\\/g, '\\$&');
    taglist = Object.keys(doT.tags).sort();
    for (t_id in taglist) {
      t_name = taglist[t_id];
      str = str.replace(doT.tags[t_name].regex, doT.tags[t_name].func);
    }
    str = ("var out='" + str + "';return out;").replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/\r/g, '\\r').replace(/(\s|;|}|^|{)out\+='';/g, '$1').replace(/\+''/g, '').replace(/(\s|;|}|^|{)out\+=''\+/g, '$1out+=');
    if (c["with"]) {
      str = "with(" + (true === c["with"] ? c.varname : c["with"]) + ") {" + str + "}";
    }
    try {
      return new Function(c.varname, str);
    } catch (e) {
      throw "" + e + " in " + str;
    }
  };

  doT.getCached = function() {
    return cache;
  };

  doT.setCached = function(fns) {
    return cache = fns;
  };

  doT.exportCached = function() {
    var f, id, str;
    str = "";
    for (id in cache) {
      f = cache[id];
      str += ",\"" + id + "\": " + (f.toString());
    }
    return "{" + (str.substring(1)) + "}";
  };

  doT.addCached = function(id, fn) {
    var f, i;
    if ('object' === typeof id) {
      for (i in id) {
        f = id[i];
        doT.addCached(i, f);
      }
      return;
    }
    return cache[id] = fn;
  };

  doT.render = function(tmpl, cb) {
    var src;
    ('object' !== typeof tmpl) && (tmpl = {
      name: tmpl
    });
    if (!cache[tmpl.name]) {
      src = doT.autoload(tmpl.name);
      if (false === src) {
        throw "Template not found: " + tmpl.name;
      }
      doT.addCached(tmpl.name, doT.compile(src));
    }
    return cache[tmpl.name].apply(this, tmpl.args || Array.prototype.slice.call(arguments, 1));
  };

  doT.autoloadDOM = function(opts) {
    return function(name) {
      var src;
      src = document.getElementById(name);
      if (!src || !src.type || 'text/x-dot-tmpl' !== src.type) {
        return false;
      } else {
        return src.innerHTML;
      }
    };
  };

  doT.autoloadFS = function(opts) {
    return function(name) {
      try {
        return opts.fs.readFileSync("" + opts.root + "/" + (name.replace('.', '/')) + ".tmpl");
      } catch (e) {
        return false;
      }
    };
  };

  doT.autoload = doT.autoloadDOM();

}).call(this);
